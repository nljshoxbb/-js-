<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>TEst</title>
    <meta http-equiv="X-UA-Compatible" content="ie=edge" />
    <meta http-equiv="Content-Type" content="text/html;charset=UTF-8" />
    <meta name="renderer" content="webkit" />
    <style>
      * {
        margin: 0;
        padding: 0;
      }
    </style>
  </head>

  <body></body>
  <script>
    function Promise(executor) {
      var self = this;

      self.status = "pending";
      self.onResolvedCallback = [];
      self.onRejectedCallback = [];

      function resolve(value) {
        if (value instanceof Promise) {
          return value.then(resolve, reject);
        }
        setTimeout(function() {
          // 异步执行所有的回调函数
          if (self.status === "pending") {
            self.status = "resolved";
            self.data = value;
            for (var i = 0; i < self.onResolvedCallback.length; i++) {
              self.onResolvedCallback[i](value);
            }
          }
        });
      }

      function reject(reason) {
        setTimeout(function() {
          // 异步执行所有的回调函数
          if (self.status === "pending") {
            self.status = "rejected";
            self.data = reason;
            for (var i = 0; i < self.onRejectedCallback.length; i++) {
              self.onRejectedCallback[i](reason);
            }
          }
        });
      }

      try {
        executor(resolve, reject);
      } catch (reason) {
        reject(reason);
      }
    }

    function resolvePromise(promise2, x, resolve, reject) {
      var then;
      var thenCalledOrThrow = false;

      if (promise2 === x) {
        return reject(new TypeError("Chaining cycle detected for promise!"));
      }

      if (x instanceof Promise) {
        if (x.status === "pending") {
          //because x could resolved by a Promise Object
          x.then(function(v) {
            resolvePromise(promise2, v, resolve, reject);
          }, reject);
        } else {
          //but if it is resolved, it will never resolved by a Promise Object but a static value;
          x.then(resolve, reject);
        }
        return;
      }

      if (x !== null && (typeof x === "object" || typeof x === "function")) {
        try {
          then = x.then; //because x.then could be a getter
          if (typeof then === "function") {
            then.call(
              x,
              function rs(y) {
                if (thenCalledOrThrow) return;
                thenCalledOrThrow = true;
                return resolvePromise(promise2, y, resolve, reject);
              },
              function rj(r) {
                if (thenCalledOrThrow) return;
                thenCalledOrThrow = true;
                return reject(r);
              }
            );
          } else {
            resolve(x);
          }
        } catch (e) {
          if (thenCalledOrThrow) return;
          thenCalledOrThrow = true;
          return reject(e);
        }
      } else {
        resolve(x);
      }
    }

    Promise.prototype.then = function(onResolved, onRejected) {
      var self = this;
      var promise2;
      onResolved =
        typeof onResolved === "function"
          ? onResolved
          : function(v) {
              return v;
            };
      onRejected =
        typeof onRejected === "function"
          ? onRejected
          : function(r) {
              throw r;
            };

      if (self.status === "resolved") {
        return (promise2 = new Promise(function(resolve, reject) {
          setTimeout(function() {
            // 异步执行onResolved
            try {
              // var x = onResolved(self.data);
              // resolvePromise(promise2, x, resolve, reject);
              var x = onResolved(self.data);
              if (x instanceof Promise) {
                // 如果onResolved的返回值是一个Promise对象，直接取它的结果做为promise2的结果
                x.then(resolve, reject);
              }
              resolve(x); // 否则，以它的返回值做为promise2的结果
            } catch (reason) {
              reject(reason);
            }
          });
        }));
      }

      if (self.status === "rejected") {
        return (promise2 = new Promise(function(resolve, reject) {
          setTimeout(function() {
            // 异步执行onRejected
            try {
              // var x = onRejected(self.data);
              // resolvePromise(promise2, x, resolve, reject);
              var x = onRejected(self.data);
              if (x instanceof Promise) {
                x.then(resolve, reject);
              }
            } catch (reason) {
              reject(reason);
            }
          });
        }));
      }

      if (self.status === "pending") {
        // 这里之所以没有异步执行，是因为这些函数必然会被resolve或reject调用，而resolve或reject函数里的内容已是异步执行，构造函数里的定义
        return (promise2 = new Promise(function(resolve, reject) {
          self.onResolvedCallback.push(function(value) {
            try {
              // var x = onResolved(value);
              // resolvePromise(promise2, x, resolve, reject);
              var x = onResolved(value);
              if (x instanceof Promise) {
                x.then(resolve, reject);
              }
              resolve(x);
            } catch (r) {
              reject(r);
            }
          });

          self.onRejectedCallback.push(function(reason) {
            try {
              // var x = onRejected(reason);
              // resolvePromise(promise2, x, resolve, reject);
              var x = onRejected(self.data);
              if (x instanceof Promise) {
                x.then(resolve, reject);
              }
            } catch (r) {
              reject(r);
            }
          });
        }));
      }
    };

    Promise.prototype.catch = function(onRejected) {
      return this.then(null, onRejected);
    };

    Promise.deferred = Promise.defer = function() {
      var dfd = {};
      dfd.promise = new Promise(function(resolve, reject) {
        dfd.resolve = resolve;
        dfd.reject = reject;
      });
      return dfd;
    };

    Promise.all = function(promises) {
      return new Promise(function(resolve, reject) {
        var resolvedCounter = 0;
        var promiseNum = promises.length;
        var resolvedValues = new Array(promiseNum);
        for (var i = 0; i < promiseNum; i++) {
          (function(i) {
            Promise.resolve(promises[i]).then(
              function(value) {
                resolvedCounter++;
                resolvedValues[i] = value;
                if (resolvedCounter == promiseNum) {
                  return resolve(resolvedValues);
                }
              },
              function(reason) {
                reject(reason);
              }
            );
          })(i);
        }
      });
    };

    var promise1 = new Promise((resolve, reject) => {
      resolve("111");
    });

    promise1
      .then(function(value) {
        // console.log(value + "then1");
        // return "then1";
        return new Promise((resolve, reject) => {
          resolve("test");
        });
      })
      .then(function(value) {
        console.log(value + "then2");
      })
      .catch(function(value) {
        console.error("catch" + value);
      });
  </script>
</html>

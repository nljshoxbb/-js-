## 1. HTTP 请求类型

* GET：向特定的资源发出请求
* POST：向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST 请求可能会导致新的资源的创建和/或已有资源的修改
* PUT：向指定资源位置上传其最新内容
* DELETE：请求服务器删除 Request-URI 所标识的资源
* OPTIONS：返回服务器针对特定资源所支持的 HTTP 请求方法。也可以利用向 Web 服务器发送’\*’的请求来测试服务器的性能。

## 2. HTTP 请求四部分

1.  HTTP 请求的方法或动作，比如是 get 还是 post 请求；
2.  正在请求的 URL（请求的地址）；
3.  请求头，包含一些客户端环境信息、身份验证信息等；
4.  请求体（请求正文），可以包含客户提交的查询字符串信息、表单信息等。

请求头字段：

```
Accept:text/html,image/\*  [告诉服务器，浏览器可以接受文本，网页图片]
Accept-Charaset:ISO-8859-1 [接受字符编码：iso-8859-1]
Accept-Encoding:gzip,compress[可以接受 gzip,compress 压缩后数据]
Accept-Language:zh-cn[浏览器支持的语言]
Host:localhost:8080[浏览器要找的主机]
If-Modified-Since:Tue, 09 May 2017 01:34:02 GMT [告诉服务器我这缓存中有这个文件,该文件的时间是…]
User-Agent:Nozilla/4.0(Com…)[告诉服务器我的浏览器内核，客户端环境信]
Cookie：[身份验证信息]
Connection:close/Keep-Alive [保持链接，发完数据后，我不关闭链接]
```

## 3.HTTP 响应三部分

1.  一个数字和文字组成的状态码，用来显示请求是成功还是失败；
2.  响应头，响应头也和请求头一样包含许多有用的信息，例如服务器类型、日期时间、内容类型和长度等；
3.  响应体（响应正文）

响应头字段：

```
Cache-Control:[告诉浏览器如何缓存页面(因为浏览器的兼容性最好设置两个)]
Connection:close/Keep-Alive [保持链接，发完数据后，我不关闭链接]
Content-Type:text/html;charset=gb2312[内容格式和编码]
Last-Modified:Tue,11 Juj,2017 18 18:29:20[告诉浏览器该资源上次更新时间是多少]
ETag:”540-54f0d59b8b680”
Expires:Fri, 26 May 2017 13:28:33 GMT [失效日期]
server:apache tomcat nginx [哪种服务器]
```

## 4.说说 TCP 传输的三次握手

* 第一次握手，客户端给服务器发送数据包（**带 SYN 标志的数据包**）。此时服务器确认自己可以接收客户端的包，而客户端不确认服务器是否接收到了自己发的数据包。

* 第二次握手，服务器端回复（**回传一个带有 SYN/ACK 标志的数据包以示传达确认信息**）客户端。此时客户端确认自己发的包被服务器收到，也确认自己可以正常接收服务器包，客户端对此次通信没有疑问了。服务器也可以确认自己能接收到客户端的包，但不能确认客户端能否接收自己发的包。

* 第三次握手，客户端回复（**发送端再回传一个带 ACK 标志的数据包，代表“握手”结束**）服务器。 客户端已经没有疑问了，服务器也确认刚刚客户端收到了自己的数据包。两边都没有问题，开始通信。

### 为什么要三次握手：

为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误。也防止了服务器端的一直等待而浪费资源

TCP 作为一种可靠传输控制协议，其核心思想：既要保证数据可靠传输，又要提高传输的效率，而用三次恰恰可以满足以上两方面的需求！

若在握手过程中某个阶段莫名中断，TCP 协议会再次以相同的顺序发送相同的数据包。

## 5. 四次挥手

1.  主动关闭方发送一个 `FIN`，用来关闭主动方到被动关闭方的数据传送，也就是主动关闭方告诉被动关闭方：我已经不 会再给你发数据了(当然，在 `fin` 包之前发送出去的数据，如果没有收到对应的 `ack` 确认报文，主动关闭方依然会重发这些数据)，但是，此时主动关闭方还可以接受数据。
2.  被动关闭方收到`FIN`包后，发送一个`ACK`给对方，确认序号为收到序号+1（与`SYN`相同，一个`FIN`占用一个序号）
3.  被动关闭方发送一个`FIN`，用来关闭被动关闭方到主动关闭方的数据传送，也就是告诉主动关闭方，我的数据也发送完了，不会再给你发数据了。
4.  主动关闭方收到`FIN`后，发送一个`ACK`给被动关闭方，确认序号为收到序号+1，至此，完成四次挥手。

## 6.TCP 和 UDP 的区别

TCP（Transmission Control Protocol，传输控制协议）是基于连接的协议，也就是说，在正式收发数据前，必须和对方建立可靠的连接。一个 TCP 连接必须要经过三次“对话”才能建立起来
UDP（User Data Protocol，用户数据报协议）是与 TCP 相对应的协议。它是面向非连接的协议，它不与对方建立连接，而是直接就把数据包发送过去！
UDP 适用于一次只传送少量数据、对可靠性要求不高的应用环境

## 7.HTTP 和 HTTPS

1.  HTTP 协议通常承载于 TCP 协议之上，在 HTTP 和 TCP 之间添加一个安全协议层（SSL 或 TSL），这个时候，就成了我们常说的 HTTPS
2.  默认 HTTP 的端口号为 80，HTTPS 的端口号为 443
    HTTPS 相对于 HTTP 性能上差点，因为多了 SSL/TLS 的几次握手和加密解密的运算处理，但是加密解密的运算处理已经可以通过特有的硬件来加速处理。

## 8.关于 Http 2.0 你知道多少？

* 引入了“服务端推（server push）”的概念，它允许服务端在客户端需要数据之前就主动地将数据发送到客户端缓存中，从而提高性能。
* 提供更多的加密支持
* 使用多路技术，允许多个消息在一个连接上同时交差。它增加了头压缩（header compression），因此即使非常小的请求，其请求和响应的 header 都只会占用很小比例的带宽。

## 9.从浏览器地址栏输入 url 到显示页面的步骤(以 HTTP 为例)

1.  在浏览器地址栏输入 URL
2.  浏览器查看**缓存**，如果请求资源在缓存中并且没有过期，跳转到转码步骤
    1.  如果资源未缓存，发起新请求
    2.  如果已缓存，检验是否已过期，没有过期直接提供给客户端，否则与服务器进行验证。
    3.  检验缓存是过期通常有两个 HTTP 头进行控制`Expires`和`Cache-Control`：
        * HTTP1.0 提供 Expires，值为一个绝对时间表示缓存过期日期
        * HTTP1.1 增加了 Cache-Control: max-age=,值为以秒为单位的最大过期时间
3.  浏览器**解析 URL**获取协议，主机，端口，path
4.  浏览器**组装一个 HTTP（GET）请求报文**
5.  浏览器**获取主机 ip 地址**，过程如下：
    1.  浏览器缓存
    2.  本机缓存
    3.  hosts 文件
    4.  路由器缓存
    5.  ISP DNS 缓存
    6.  DNS 递归查询（可能存在负载均衡导致每次 IP 不一样）
6.  **打开一个 socket 与目标 IP 地址，端口建立 TCP 链接**，三次握手如下：
    1.  客户端发送一个 TCP 的**SYN=1，Seq=X**的包到服务器端口
    2.  服务器发回**SYN=1， ACK=X+1， Seq=Y**的响应包
    3.  客户端发送**ACK=Y+1， Seq=Z**
7.  TCP 链接建立后**发送 HTTP 请求**
8.  服务器接受请求并解析，将请求转发到服务程序，如虚拟主机使用 HTTP Host 头部判断请求的服务程序
9.  服务器检查**HTTP 请求头是否包含缓存验证信息**如果验证缓存没有过期，返回**304**等对应状态码
10. 处理程序读取完整请求并准备 HTTP 响应，可能需要查询数据库等操作
11. 服务器将**响应报文通过 TCP 连接发送回浏览器**
12. 浏览器接收 HTTP 响应，然后根据情况选择**关闭 TCP 连接或者保留重用，关闭 TCP 连接的四次握手如下**：
    1.  主动方发送**Fin=1， Ack=Z， Seq= X**报文
    2.  被动方发送**ACK=X+1， Seq=Z**报文
    3.  被动方发送**Fin=1， ACK=X， Seq=Y**报文
    4.  主动方发送**ACK=Y， Seq=X**报文
13. 浏览器检查响应状态吗：是否为 1XX，3XX， 4XX， 5XX，这些情况处理与 2XX 不同
14. 如果资源可缓存，**进行缓存**
15. 对响应进行**解码**（例如 gzip 压缩）
16. 根据资源类型决定如何处理（假设资源为 HTML 文档）
17. **解析 HTML 文档，构件 DOM 树，下载资源，构造 CSSOM 树，执行 js 脚本**，这些操作没有严格的先后顺序，以下分别解释
18. **构建 DOM 树**：
    1.  **Tokenizing**：根据 HTML 规范将字符流解析为标记
    2.  **Lexing**：词法分析将标记转换为对象并定义属性和规则
    3.  **DOM construction**：根据 HTML 标记关系将对象组成 DOM 树
19. 解析过程中遇到图片、样式表、js 文件，**启动下载**
20. 构建**CSSOM 树**：
    1.  **Tokenizing**：字符流转换为标记流
    2.  **Node**：根据标记创建节点
    3.  **CSSOM**：节点创建 CSSOM 树
21. **[根据 DOM 树和 CSSOM 树构建渲染树](https://developers.google.com/web/fundamentals/performance/critical-rendering-path/render-tree-construction)**:
    1.  从 DOM 树的根节点遍历所有**可见节点**，不可见节点包括：1）`script`,`meta`这样本身不可见的标签。2)被 css 隐藏的节点，如`display: none`
    2.  对每一个可见节点，找到恰当的 CSSOM 规则并应用
    3.  发布可视节点的内容和计算样式
22. **js 解析如下**：
    1.  浏览器创建 Document 对象并解析 HTML，将解析到的元素和文本节点添加到文档中，此时**document.readystate 为 loading**
    2.  HTML 解析器遇到**没有 async 和 defer 的 script 时**，将他们添加到文档中，然后执行行内或外部脚本。这些脚本会同步执行，并且在脚本下载和执行时解析器会暂停。这样就可以用 document.write()把文本插入到输入流中。**同步脚本经常简单定义函数和注册事件处理程序，他们可以遍历和操作 script 和他们之前的文档内容**
    3.  当解析器遇到设置了**async**属性的 script 时，开始下载脚本并继续解析文档。脚本会在它**下载完成后尽快执行**，但是**解析器不会停下来等它下载**。异步脚本**禁止使用 document.write()**，它们可以访问自己 script 和之前的文档元素
    4.  当文档完成解析，document.readState 变成 interactive
    5.  所有**defer**脚本会**按照在文档出现的顺序执行**，延迟脚本**能访问完整文档树**，禁止使用 document.write()
    6.  浏览器**在 Document 对象上触发 DOMContentLoaded 事件**
    7.  此时文档完全解析完成，浏览器可能还在等待如图片等内容加载，等这些**内容完成载入并且所有异步脚本完成载入和执行**，document.readState 变为 complete,window 触发 load 事件
23. **显示页面**（HTML 解析过程中会逐步显示页面）

## 10.讲讲 304 缓存的原理

服务器首先产生 `ETag`，服务器可在稍后使用它来判断页面是否已经被修改。本质上，客户端通过将该记号传回服务器要求服务器验证其（客户端）缓存。
`304` 是 HTTP 状态码，服务器用来标识这个文件没修改，不返回内容，浏览器在接收到个状态码后，会使用浏览器已缓存的文件

客户端请求一个页面（A）。 服务器返回页面 A，并在给 A 加上一个 `ETag`。 客户端展现该页面，并将页面连同 `ETag` 一起缓存。 客户再次请求页面 A，并将上次请求时服务器返回的 `ETag` 一起传递给服务器。 服务器检查该 `ETag`，并判断出该页面自上次客户端请求之后还未被修改，直接返回响应 `304`（未修改——`Not Modified`）和一个空的响应体。

## 11.常见 web 安全及防护原理

1.  sql 注入,就是通过把 SQL 命令插入到 Web 表单递交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意的 SQL 命令。
2.  XSS,指的是攻击者往 Web 页面里插入恶意 html 标签或者 javascript 代码。比如：攻击者在论坛中放一个看似安全的链接，骗取用户点击后，窃取 cookie 中的用户私密信息；或者攻击者在论坛中加一个恶意表单，当用户提交表单的时候，却把信息传送到攻击者的服务器中，而不是用户原本以为的信任站点。
3.  CSRF,是代替用户完成指定的动作，需要知道其他用户页面的代码和数据包。要完成一次 CSRF 攻击，受害者必须依次完成两个步骤：1、登录受信任网站 A，并在本地生成 Cookie。2、在不登出 A 的情况下，访问危险网站 B。

## 12. http 1.0、1.1 的区别

### 1.支持 proxy 和 Host 域

* HTTP 1.1 需要指定一个具有 host 的头部
* HTTP 1.0 并不规定需要头部带有 host，但是添加也是可以的。很多网站希望看到 host 而不管协议版本。

```
GET / HTTP/1.1
Host: www.blahblahblahblah.com
```

> 作用：带有 host 的请求头非常有用，因为它允许通过代理服务器发送消息，并且还可以让 Web 服务器区分同一服务器上的不同站点。如果你有 blahblahlbah.com 和 helohelohelo.com 都指向相同的 IP。您的 Web 服务器可以使用`host`来区分客户机所需的站点

### 2.Persistent connections (长链接)

* HTTP 1.0 需要使用 keep-alive 参数来告知服务器端要建立一个长连接，而 HTTP1.1 默认支持长连接。
* HTTP 是基于 TCP/IP 协议的，创建一个 TCP 连接是需要经过三次握手的,有一定的开销，如果每次通讯都要重新建立连接的话，对性能有影响。因此最好能维持一个长连接，可以用个长连接来发多个请求。

### 3.OPTIONS 方法

HTTP / 1.1 引入了 OPTIONS 方法。 HTTP 客户端可以使用此方法来确定 HTTP 服务器的功能。它主要用于 Web 应用程序中的跨源资源共享(跨域)

### 4.Caching (缓存)

* HTTP 1.0 支持通过头部声明`If-Modified-Since`进行缓存。
* HTTP 1.1 通过使用称为`entity tag`的东西来扩展缓存支持。如果 2 个资源相同，那么它们将具有相同的`entity tags`
* HTTP 1.1 还添加了 `If-Unmodified-Since`，`If-Match`，`If-None-Match`条件标头
* 还有一些与高速缓存相关的附加内容，如 Cache-Control 标头

### 5. 100 Continue status(100 继续状态)

* HTTP 1.1 支持只发送 header 信息(不带任何 body 信息)，如果服务器认为客户端有权限请求服务器，则返回 100，否则返回 401。客户端如果接受到 100，才开始把请求 body 发送到服务器。这样当服务器返回 401 的时候，客户端就可以不用发送请求 body 了，节约了带宽。
* HTTP 还支持传送内容的一部分。这样当客户端已经有一部分的资源后，只需要跟服务器请求另外的部分资源即可。这是支持文件**断点续传**的基础。

### 6. 分块传输编码等

## 13. http1.1 和 http2 区别

### 1.多路复用 (Multiplexing)

**多路复用允许同时通过单一的 HTTP/2 连接发起多重的请求-响应消息。**

* HTTP/1.1 协议中 **浏览器客户端在同一时间，针对同一域名下的请求有一定数量限制。超过限制数目的请求会被阻塞**。这也是为何一些站点会有多个静态资源 CDN 域名的原因之一，拿 Twitter 为例，http://twimg.com，目的就是变相的解决浏览器针对同一域名的请求限制阻塞问题。

* HTTP/2 的多路复用(Multiplexing) 则允许同时通过单一的 HTTP/2 连接发起多重的**请求-响应**。因此 HTTP/2 可以很容易的去实现多流并行而不用依赖建立多个 TCP 连接，HTTP/2 把 HTTP 协议通信的基本单位缩小为一个一个的帧，这些帧对应着逻辑流中的消息。并行地在同一个 TCP 连接上**双向交换**消息

### 2.二进制分帧

* 在二进制分帧层中， HTTP/2 会将所有传输的信息分割为更小的消息和帧（frame）,并对它们采用二进制格式的编码 ，其中 HTTP1.x 的首部信息会被封装到 HEADER frame，而相应的 Request Body 则封装到 DATA frame 里面。
* HTTP/2 通信都在一个连接上完成，这个连接可以承载任意数量的双向数据流。
* 在过去， HTTP 性能优化的**关键并不在于高带宽**，而是**低延迟**。TCP 连接会随着时间进行自我「调谐」，起初会限制连接的最大速度，如果数据成功传输，会随着时间的推移提高传输的速度。这种调谐则被称为 TCP 慢启动。由于这种原因，让原本就具有突发性和短时性的 HTTP 连接变的十分低效。
* HTTP/2 通过让所有数据流共用同一个连接，可以更有效地使用 TCP 连接，让高带宽也能真正的服务于 HTTP 的性能提升。

总结：

* 单连接多资源的方式，减少服务端的链接压力,内存占用更少,连接吞吐量更大
* 由于 TCP 连接的减少而使网络拥塞状况得以改善，同时慢启动时间的减少,使拥塞和丢包恢复速度更快

### 3.首部压缩（Header Compression）

HTTP/1.1 并不支持 HTTP 首部压缩，为此 SPDY 和 HTTP/2 应运而生， SPDY 使用的是通用的 DEFLATE 算法，而 HTTP/2 则使用了专门为首部压缩而设计的 HPACK 算法。

### 4. 服务端推送（Server Push）

服务端推送是一种在客户端请求之前发送数据的机制。

* 在 HTTP/2 中，服务器可以对客户端的一个请求发送多个响应。
* Server Push 让 HTTP1.x 时代使用内嵌资源的优化手段变得没有意义；
* 如果一个请求是由你的主页发起的，服务器很可能会响应主页内容、logo 以及样式表，因为它知道客户端会用到这些东西。这相当于在一个 HTML 文档内集合了所有的资源
* 服务器推送还有一个很大的优势：可以缓存！也让在遵循同源的情况下，不同页面之间可以共享缓存资源成为可能。

## 14.http 的缓存机制

### http 报文中与缓存相关的首部字段

* 通用首部字段

* 请求首部字段

* 响应首部字段

* 实体首部字段

### 1. http 1.0 的缓存

#### (1) Pragma

* 标签中使用

```
<meta http-equiv="Pragma" content="no-cache">
```

禁用缓存的形式用处很有限:

* 仅有 IE 才能识别这段 meta 标签含义，其它主流浏览器仅能识别`Cache-Control: no-store`的 meta 标签（见出处）。
* 在 IE 中识别到该 meta 标签含义，并不一定会在请求字段加上 Pragma，但的确会让当前页面每次都发新请求（仅限页面，页面上的资源则不受影响）。

- 报文中使用

计浏览器在收到服务器的 Pragma 字段后会对资源进行标记，禁用其缓存行为，进而后续每次刷新页面均能重新发出请求而不走缓存。

#### (2) Expires

有了 Pragma 来禁用缓存，自然也需要有个东西来启用缓存和定义缓存时间，对 http1.0 而言，Expires 就是做这件事的首部字段。

* 标签中使用

```
<meta http-equiv="expires" content="mon, 18 apr 2016 14:30:00 GMT">
```

禁用缓存的形式用处很有限:

1.  在客户端我们同样可以使用 meta 标签来知会 IE（也仅有 IE 能识别）页面（同样也只对页面有效，对页面上的资源无效）缓存时间
2.  如果希望在 IE 下页面不走缓存，希望每次刷新页面都能发新请求，那么可以把“content”里的值写为“-1”或“0”。
3.  注意的是该方式仅仅作为知会 IE 缓存时间的标记，你并不能在请求或响应报文中找到 Expires 字段

* 报文中使用

Pragma 禁用缓存，又给 Expires 定义一个还未到期的时间（红框），刷新页面时发现均发起了新请求（蓝框），这意味着 Pragma 字段的优先级会更高。

> 响应报文中 Expires 所定义的缓存时间是相对服务器上的时间而言的，如果客户端上的时间跟服务器上的时间不一致（特别是用户修改了自己电脑的系统时间），那缓存时间可能就没啥意义了

### 2. Cache-Control（强制缓存）

> 针对上述的“Expires 时间是相对服务器而言，无法保证和客户端时间统一”的问题，http1.1 新增了 Cache-Control 来定义缓存过期时间，若报文中同时出现了 Pragma、Expires 和 Cache-Control，会以 Cache-Control 为准。

```
"Cache-Control" ":" cache-directive
```

作为请求首部时，cache-directive 的可选值有：
![Cache-Control-request](https://github.com/nljshoxbb/fe/blob/master/img/Cache-Control-request.png)

作为响应首部时，cache-directive 的可选值有：
![Cache-Control-response](https://github.com/nljshoxbb/fe/blob/master/img/Cache-Control-response.png)

例如：

```
Cache-Control: max-age=3600, must-revalidate
```

它意味着该资源是从原服务器上取得的，且其缓存（新鲜度）的有效时间为一小时，在后续一小时内，用户重新访问该资源则无须发送请求。

no-cache 就不能和 max-age、min-fresh、max-stale 一起搭配使用。

### 3.缓存校验字段（对比缓存）

上述的首部字段均能让客户端决定是否向服务器发送请求，比如设置的缓存时间未过期，那么自然直接从本地缓存取数据即可（在 chrome 下表现为 200 from cache），若缓存时间过期了或资源不该直接走缓存，则会发请求到服务器去。

我们现在要说的问题是，如果客户端向服务器发了请求，那么是否意味着一定要读取回该资源的整个实体内容呢？

我们试着这么想——客户端上某个资源保存的缓存时间过期了，但这时候其实服务器并没有更新过这个资源，如果这个资源数据量很大，客户端要求服务器再把这个东西重新发一遍过来，是否非常浪费带宽和时间呢？

答案是肯定的，那么是否有办法让服务器知道客户端现在存有的缓存文件，其实跟自己所有的文件是一致的，然后直接告诉客户端说“这东西你直接用缓存里的就可以了，我这边没更新过呢，就不再传一次过去了”。

为了让客户端与服务器之间能实现缓存文件是否更新的验证、提升缓存的复用率，Http1.1 新增了几个首部字段来做这件事情。

#### (1)Last-Modified

服务器将资源传递给客户端时，会将资源最后更改的时间以“Last-Modified: GMT”的形式加在实体首部上一起返回给客户端。客户端会为资源标记上该信息，下次再次请求时，会把该信息附带在请求报文中一并带给服务器去做检查，若传递的时间值与服务器上该资源最终修改时间是一致的，则说明该资源没有被修改过，直接返回 304 状态码即可。

* If-Modified-Since: Last-Modified-value

```
If-Modified-Since: Thu, 31 Mar 2016 07:07:52 GMT
```

* If-Unmodified-Since: Last-Modified-value

缺点：如果在服务器上，一个资源被修改了，但其实际内容根本没发生改变，会因为 Last-Modified 时间匹配不上而返回了整个实体给客户端（即使客户端缓存里有个一模一样的资源）

#### (2) ETag

为了解决上述 Last-Modified 可能存在的不准确的问题，Http1.1 还推出了 ETag 实体首部字段。

> 服务器会通过某种算法，给资源计算得出一个唯一标志符（比如 md5 标志），在把资源响应给客户端的时候，会在实体首部加上“ETag: 唯一标识符”一起返回给客户端。

客户端会保留该 ETag 字段，并在下一次请求时将其一并带过去给服务器。服务器只需要比较客户端传来的 ETag 跟自己服务器上该资源的 ETag 是否一致，就能很好地判断资源相对客户端而言是否被修改过了。

如果服务器发现 ETag 匹配不上，那么直接以常规 GET 200 回包形式将新的资源（当然也包括了新的 ETag）发给客户端；如果 ETag 是一致的，则直接返回 304 知会客户端直接使用本地缓存即可。

客户端通过两种方式把标记在资源上的 ETag 传去给服务器

##### (3) If-None-Match: ETag-value

```
If-None-Match: "56fcccc8-1699"
```

告诉服务端如果 ETag 没匹配上需要重发资源数据，否则直接回送 304 和响应报头即可。

##### (4) If-Match: ETag-value

应用场景：客户端走 PUT 方法向服务端请求上传/更替资源，这时候可以通过 If-Match 传递资源的 ETag。

> Last-Modified 和 ETag 同时被使用，则要求它们的验证都必须通过才会返回 304，若其中某个验证没通过，则服务器会按常规返回资源实体及 200 状态码。

**浏览器第一次请求**：
![cache-first](https://github.com/nljshoxbb/fe/blob/master/img/cache-first.png)
**浏览器再次请求时**：
![cache](https://github.com/nljshoxbb/fe/blob/master/img/cache.png)

## 15. 为什么 HTTPS 安全

因为网络请求需要中间有很多的服务器路由器的转发。中间的节点都可能篡改信息，而如果使用 HTTPS，密钥在你和终点站才有。https 之所以比 http 安全，是因为他利用 ssl/tls 协议传输。它包含证书，卸载，流量转发，负载均衡，页面适配，浏览器适配，refer 传递等。保障了传输过程的安全性

## 16.HTTP 中 Get 与 Post 的区别

1.  `GET` 请求的数据会附在 URL 之后（就是把数据放置在 HTTP 协议头中），以?分割 URL 和传输数据，参数之间以&相连。`POST` 把提交的数据则放置在是 HTTP 包的包体中
2.  `GET` 请求的 URL 不存在参数上限的问题，HTTP 协议规范没有对 URL 长度进行限制。这个限制是特定的浏览器及服务器对它的限制。
3.  `POST` 是没有大小限制的，HTTP 协议规范也没有进行大小限制。起限制作用的是服务器的处理程序的处理能力。
4.  `POST` 的安全性要比 `GET` 的安全性高。比如：通过 `GET` 提交数据，用户名和密码将明文出现在 URL 上，因为
    (1)登录页面有可能被浏览器缓存，
    (2)其他人查看浏览器的历史纪录，那么别人就可以拿到你的账号和密码了，除此之外，使用 `GET` 提交数据还可能会造成 `Cross-site request forgery` 攻击

## 17.说说网络分层里七层模型是哪七层

1.  应用层：应用层、表示层、会话层（从上往下）`（HTTP、FTP、SMTP、DNS）`
2.  传输层（TCP 和 UDP）
3.  网络层（IP）
4.  物理和数据链路层（以太网）

每一层的作用如下：

* 物理层：通过媒介传输比特,确定机械及电气规范（比特 Bit）
* 数据链路层：将比特组装成帧和点到点的传递（帧 Frame）
* 网络层：负责数据包从源到宿的传递和网际互连（包 PackeT）
* 传输层：提供端到端的可靠报文传递和错误恢复（段 Segment）
* 会话层：建立、管理和终止会话（会话协议数据单元 SPDU）
* 表示层：对数据进行翻译、加密和压缩（表示协议数据单元 PPDU）
* 应用层：允许访问 OSI 环境的手段（应用协议数据单元 APDU）

## 18.HTTP request 报文结构是怎样的

[rfc2616](http://www.w3.org/Protocols/rfc2616/rfc2616-sec5.html)中进行了定义：

1.  首行是**Request-Line**包括：**请求方法**，**请求 URI**，**协议版本**，**CRLF**
2.  首行之后是若干行**请求头**，包括**general-header**，**request-header**或者**entity-header**，每个一行以 CRLF 结束
3.  请求头和消息实体之间有一个**CRLF 分隔**
4.  根据实际请求需要可能包含一个**消息实体**
    一个请求报文例子如下：

```
GET /Protocols/rfc2616/rfc2616-sec5.html HTTP/1.1
Host: www.w3.org
Connection: keep-alive
Cache-Control: max-age=0
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8
User-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/35.0.1916.153 Safari/537.36
Referer: https://www.google.com.hk/
Accept-Encoding: gzip,deflate,sdch
Accept-Language: zh-CN,zh;q=0.8,en;q=0.6
Cookie: authorstyle=yes
If-None-Match: "2cc8-3e3073913b100"
If-Modified-Since: Wed, 01 Sep 2004 13:24:52 GMT

name=qiu&age=25
```

## 19. HTTP response 报文结构是怎样的

[rfc2616](http://www.w3.org/Protocols/rfc2616/rfc2616-sec6.html)中进行了定义：

1.  首行是状态行包括：**HTTP 版本，状态码，状态描述**，后面跟一个 CRLF
2.  首行之后是**若干行响应头**，包括：**通用头部，响应头部，实体头部**
3.  响应头部和响应实体之间用**一个 CRLF 空行**分隔
4.  最后是一个可能的**消息实体**
    响应报文例子如下：

```
HTTP/1.1 200 OK
Date: Tue, 08 Jul 2014 05:28:43 GMT
Server: Apache/2
Last-Modified: Wed, 01 Sep 2004 13:24:52 GMT
ETag: "40d7-3e3073913b100"
Accept-Ranges: bytes
Content-Length: 16599
Cache-Control: max-age=21600
Expires: Tue, 08 Jul 2014 11:28:43 GMT
P3P: policyref="http://www.w3.org/2001/05/P3P/p3p.xml"
Content-Type: text/html; charset=iso-8859-1

{"name": "qiu", "age": 25}
```

## 20.

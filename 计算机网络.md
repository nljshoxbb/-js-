## 1. HTTP 请求类型

> GET：向特定的资源发出请求
> POST：向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST 请求可能会导致新的资源的创建和/或已有资源的修改
> PUT：向指定资源位置上传其最新内容
> DELETE：请求服务器删除 Request-URI 所标识的资源
> OPTIONS：返回服务器针对特定资源所支持的 HTTP 请求方法。也可以利用向 Web 服务器发送’\*’的请求来测试服务器的性能。

## 2. HTTP 请求四部分

> 1、HTTP 请求的方法或动作，比如是 get 还是 post 请求；
> 2、正在请求的 URL（请求的地址）；
> 3、请求头，包含一些客户端环境信息、身份验证信息等；
> 4、请求体（请求正文），可以包含客户提交的查询字符串信息、表单信息等。

### 请求头字段：

> Accept:text/html,image/\*(告诉服务器，浏览器可以接受文本，网页图片)
> Accept-Charaset:ISO-8859-1 [接受字符编码：iso-8859-1]
> Accept-Encoding:gzip,compress[可以接受 gzip,compress 压缩后数据]
> Accept-Language:zh-cn[浏览器支持的语言]
> Host:localhost:8080[浏览器要找的主机]
> If-Modified-Since:Tue, 09 May 2017 01:34:02 GMT[告诉服务器我这缓存中有这个文件,该文件的时间是…]
> User-Agent:Nozilla/4.0(Com…)[告诉服务器我的浏览器内核，客户端环境信]
> Cookie：[身份验证信息]
> Connection:close/Keep-Alive [保持链接，发完数据后，我不关闭链接]

## 3.HTTP 响应三部分

> 1、一个数字和文字组成的状态码，用来显示请求是成功还是失败；
> 2、响应头，响应头也和请求头一样包含许多有用的信息，例如服务器类型、日期时间、内容类型和长度等；
> 3、响应体（响应正文）

### 响应头字段：

> Cache-Control:[告诉浏览器如何缓存页面(因为浏览器的兼容性最好设置两个)]
> Connection:close/Keep-Alive [保持链接，发完数据后，我不关闭链接]
> Content-Type:text/html;charset=gb2312[内容格式和编码]
> Last-Modified:Tue,11 Juj,2017 18 18:29:20[告诉浏览器该资源上次更新时间是多少]
> ETag:”540-54f0d59b8b680”
> Expires:Fri, 26 May 2017 13:28:33 GMT [失效日期]
> server:apache tomcat nginx [哪种服务器]

## 4.说说 TCP 传输的三次握手

> 第一次握手，客户端给服务器发送数据包（**带 SYN 标志的数据包**）。此时服务器确认自己可以接收客户端的包，而客户端不确认服务器是否接收到了自己发的数据包。

> 第二次握手，服务器端回复（**回传一个带有 SYN/ACK 标志的数据包以示传达确认信息**）客户端。此时客户端确认自己发的包被服务器收到，也确认自己可以正常接收服务器包，客户端对此次通信没有疑问了。服务器也可以确认自己能接收到客户端的包，但不能确认客户端能否接收自己发的包。

> 第三次握手，客户端回复（**发送端再回传一个带 ACK 标志的数据包，代表“握手”结束**）服务器。 客户端已经没有疑问了，服务器也确认刚刚客户端收到了自己的数据包。两边都没有问题，开始通信。

### 为什么要三次握手：

> 为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误。也防止了服务器端的一直等待而浪费资源
> TCP 作为一种可靠传输控制协议，其核心思想：既要保证数据可靠传输，又要提高传输的效率，而用三次恰恰可以满足以上两方面的需求！

## 5. 四次挥手

> 1、主机向服务器发送一个断开连接的请求（ 不早了，我该走了 ）,**发送一个 FIN 报文段**；
> 2、服务器接到请求后发送确认收到请求的信号（ 知道了 ）**回一个 ACK 报文段**；
> 3、服务器向主机发送断开通知（ 我也该走了 ）**发送 FIN 报文段，请求关闭连接**；
> 4、主机接到断开通知后断开连接并反馈一个确认信号（ 嗯，好的 ），服务器收到确认信号后也断开连接；

## 6.TCP 和 UDP 的区别

> TCP（Transmission Control Protocol，传输控制协议）是基于连接的协议，也就是说，在正式收发数据前，必须和对方建立可靠的连接。一个 TCP 连接必须要经过三次“对话”才能建立起来
> UDP（User Data Protocol，用户数据报协议）是与 TCP 相对应的协议。它是面向非连接的协议，它不与对方建立连接，而是直接就把数据包发送过去！
> UDP 适用于一次只传送少量数据、对可靠性要求不高的应用环境

## 7.HTTP 和 HTTPS

> 1、HTTP 协议通常承载于 TCP 协议之上，在 HTTP 和 TCP 之间添加一个安全协议层（SSL 或 TSL），这个时候，就成了我们常说的 HTTPS
> 2、默认 HTTP 的端口号为 80，HTTPS 的端口号为 443
> HTTPS 相对于 HTTP 性能上差点，因为多了 SSL/TLS 的几次握手和加密解密的运算处理，但是加密解密的运算处理已经可以通过特有的硬件来加速处理。

## 8.关于 Http 2.0 你知道多少？

> HTTP/2 引入了“服务端推（server push）”的概念，它允许服务端在客户端需要数据之前就主动地将数据发送到客户端缓存中，从而提高性能。
> HTTP/2 提供更多的加密支持
> HTTP/2 使用多路技术，允许多个消息在一个连接上同时交差。它增加了头压缩（header compression），因此即使非常小的请求，其请求和响应的 header 都只会占用很小比例的带宽。

## 9.一个页面从输入 URL 到页面加载显示完成，这个过程中都发生了什么？

> 1、浏览器根据请求的 URL 交给 DNS 域名解析，找到真实 IP，向服务器发起请求（TCP 三次握手）；
> 2、服务器交给后台处理完成后返回数据，浏览器接收文件（HTML、JS、CSS、图象等）；
> 3、浏览器对加载到的资源（HTML、JS、CSS 等）进行语法解析，建立相应的内部数据结构（如 HTML 的 DOM）；
> 4、载入解析到的资源文件，渲染页面，完成。

## 10.讲讲 304 缓存的原理

> 服务器首先产生 ETag，服务器可在稍后使用它来判断页面是否已经被修改。本质上，客户端通过将该记号传回服务器要求服务器验证其（客户端）缓存。
> 304 是 HTTP 状态码，服务器用来标识这个文件没修改，不返回内容，浏览器在接收到个状态码后，会使用浏览器已缓存的文件

## 11.常见 web 安全及防护原理

> 1.sql 注入,就是通过把 SQL 命令插入到 Web 表单递交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意的 SQL 命令。
> 2.XSS,指的是攻击者往 Web 页面里插入恶意 html 标签或者 javascript 代码。比如：攻击者在论坛中放一个看似安全的链接，骗取用户点击后，窃取 cookie 中的用户私密信息；或者攻击者在论坛中加一个恶意表单，当用户提交表单的时候，却把信息传送到攻击者的服务器中，而不是用户原本以为的信任站点。
> 3.CSRF,是代替用户完成指定的动作，需要知道其他用户页面的代码和数据包。要完成一次 CSRF 攻击，受害者必须依次完成两个步骤：1、登录受信任网站 A，并在本地生成 Cookie。2、在不登出 A 的情况下，访问危险网站 B。

## 12. http 1.0、1.1 的区别

### 1.支持 proxy 和 Host 域

> * HTTP 1.1 需要指定一个具有 host 的头部
> * HTTP 1.0 并不规定需要头部带有 host，但是添加也是可以的。很多网站希望看到 host 而不管协议版本。

```
GET / HTTP/1.1
Host: www.blahblahblahblah.com
```

> 作用：带有 host 的请求头非常有用，因为它允许通过代理服务器发送消息，并且还可以让 Web 服务器区分同一服务器上的不同站点。如果你有 blahblahlbah.com 和 helohelohelo.com 都指向相同的 IP。您的 Web 服务器可以使用`host`来区分客户机所需的站点

### 2.Persistent connections (长链接)

> * HTTP 1.0 需要使用 keep-alive 参数来告知服务器端要建立一个长连接，而 HTTP1.1 默认支持长连接。
> * HTTP 是基于 TCP/IP 协议的，创建一个 TCP 连接是需要经过三次握手的,有一定的开销，如果每次通讯都要重新建立连接的话，对性能有影响。因此最好能维持一个长连接，可以用个长连接来发多个请求。

### 3.OPTIONS 方法

> HTTP / 1.1 引入了 OPTIONS 方法。 HTTP 客户端可以使用此方法来确定 HTTP 服务器的功能。它主要用于 Web 应用程序中的跨源资源共享(跨域)

### 4.Caching (缓存)

> * HTTP 1.0 支持通过头部声明`If-Modified-Since`进行缓存。
> * HTTP 1.1 通过使用称为`entity tag`的东西来扩展缓存支持。如果 2 个资源相同，那么它们将具有相同的`entity tags`
> * HTTP 1.1 还添加了 `If-Unmodified-Since`，`If-Match`，`If-None-Match`条件标头
> * 还有一些与高速缓存相关的附加内容，如 Cache-Control 标头

### 5. 100 Continue status(100 继续状态)

> HTTP 1.1 支持只发送 header 信息(不带任何 body 信息)，如果服务器认为客户端有权限请求服务器，则返回 100，否则返回 401。客户端如果接受到 100，才开始把请求 body 发送到服务器。

> 这样当服务器返回 401 的时候，客户端就可以不用发送请求 body 了，节约了带宽。

> 另外 HTTP 还支持传送内容的一部分。这样当客户端已经有一部分的资源后，只需要跟服务器请求另外的部分资源即可。这是支持文件**断点续传**的基础。

### 6. 分块传输编码 等

## 13. http1.1 和 http2 区别

### 1.多路复用 (Multiplexing)

> **多路复用允许同时通过单一的 HTTP/2 连接发起多重的请求-响应消息。**
> 众所周知 ，在 HTTP/1.1 协议中 「浏览器客户端在同一时间，针对同一域名下的请求有一定数量限制。超过限制数目的请求会被阻塞」。

> 这也是为何一些站点会有多个静态资源 CDN 域名的原因之一，拿 Twitter 为例，http://twimg.com，目的就是变相的解决浏览器针对同一域名的请求限制阻塞问题。

> 而 HTTP/2 的多路复用(Multiplexing) 则允许同时通过单一的 HTTP/2 连接发起多重的**请求-响应**

> 因此 HTTP/2 可以很容易的去实现多流并行而不用依赖建立多个 TCP 连接，HTTP/2 把 HTTP 协议通信的基本单位缩小为一个一个的帧，这些帧对应着逻辑流中的消息。并行地在同一个 TCP 连接上**双向交换**消息

### 2.二进制分帧

> 在二进制分帧层中， HTTP/2 会将所有传输的信息分割为更小的消息和帧（frame）,并对它们采用二进制格式的编码 ，其中 HTTP1.x 的首部信息会被封装到 HEADER frame，而相应的 Request Body 则封装到 DATA frame 里面。
> HTTP/2 通信都在一个连接上完成，这个连接可以承载任意数量的双向数据流。

> 在过去， HTTP 性能优化的**关键并不在于高带宽**，而是**低延迟**。TCP 连接会随着时间进行自我「调谐」，起初会限制连接的最大速度，如果数据成功传输，会随着时间的推移提高传输的速度。这种调谐则被称为 TCP 慢启动。由于这种原因，让原本就具有突发性和短时性的 HTTP 连接变的十分低效。

> HTTP/2 通过让所有数据流共用同一个连接，可以更有效地使用 TCP 连接，让高带宽也能真正的服务于 HTTP 的性能提升。

总结：

* 单连接多资源的方式，减少服务端的链接压力,内存占用更少,连接吞吐量更大
* 由于 TCP 连接的减少而使网络拥塞状况得以改善，同时慢启动时间的减少,使拥塞和丢包恢复速度更快

### 3.首部压缩（Header Compression）

> HTTP/1.1 并不支持 HTTP 首部压缩，为此 SPDY 和 HTTP/2 应运而生， SPDY 使用的是通用的 DEFLATE 算法，而 HTTP/2 则使用了专门为首部压缩而设计的 HPACK 算法。

### 4. 服务端推送（Server Push）

> 服务端推送是一种在客户端请求之前发送数据的机制。在 HTTP/2 中，服务器可以对客户端的一个请求发送多个响应。Server Push 让 HTTP1.x 时代使用内嵌资源的优化手段变得没有意义；如果一个请求是由你的主页发起的，服务器很可能会响应主页内容、logo 以及样式表，因为它知道客户端会用到这些东西。这相当于在一个 HTML 文档内集合了所有的资源，不过与之相比，服务器推送还有一个很大的优势：可以缓存！也让在遵循同源的情况下，不同页面之间可以共享缓存资源成为可能。

## 14.http 的缓存机制

### http 报文中与缓存相关的首部字段

1.  通用首部字段

2.  请求首部字段

3.  响应首部字段

4.  实体首部字段

### http 1.0 的缓存

#### 1. Pragma

##### 标签中使用

```
<meta http-equiv="Pragma" content="no-cache">
```

禁用缓存的形式用处很有限:

1.  仅有 IE 才能识别这段 meta 标签含义，其它主流浏览器仅能识别`Cache-Control: no-store`的 meta 标签（见出处）。
2.  在 IE 中识别到该 meta 标签含义，并不一定会在请求字段加上 Pragma，但的确会让当前页面每次都发新请求（仅限页面，页面上的资源则不受影响）。

##### 报文中使用

计浏览器在收到服务器的 Pragma 字段后会对资源进行标记，禁用其缓存行为，进而后续每次刷新页面均能重新发出请求而不走缓存。

#### 2. Expires

有了 Pragma 来禁用缓存，自然也需要有个东西来启用缓存和定义缓存时间，对 http1.0 而言，Expires 就是做这件事的首部字段。

##### 标签中使用

```
<meta http-equiv="expires" content="mon, 18 apr 2016 14:30:00 GMT">
```

禁用缓存的形式用处很有限:

1.  在客户端我们同样可以使用 meta 标签来知会 IE（也仅有 IE 能识别）页面（同样也只对页面有效，对页面上的资源无效）缓存时间
2.  如果希望在 IE 下页面不走缓存，希望每次刷新页面都能发新请求，那么可以把“content”里的值写为“-1”或“0”。
3.  注意的是该方式仅仅作为知会 IE 缓存时间的标记，你并不能在请求或响应报文中找到 Expires 字段

##### 报文中使用

Pragma 禁用缓存，又给 Expires 定义一个还未到期的时间（红框），刷新页面时发现均发起了新请求（蓝框），这意味着 Pragma 字段的优先级会更高。

> 响应报文中 Expires 所定义的缓存时间是相对服务器上的时间而言的，如果客户端上的时间跟服务器上的时间不一致（特别是用户修改了自己电脑的系统时间），那缓存时间可能就没啥意义了

### Cache-Control

> 针对上述的“Expires 时间是相对服务器而言，无法保证和客户端时间统一”的问题，http1.1 新增了 Cache-Control 来定义缓存过期时间，若报文中同时出现了 Pragma、Expires 和 Cache-Control，会以 Cache-Control 为准。

```
"Cache-Control" ":" cache-directive
```
作为请求首部时，cache-directive 的可选值有：
![file-list](https://www.zybuluo.com/static/img/file-list.png)

作为响应首部时，cache-directive 的可选值有：
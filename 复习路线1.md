# 一、 页面布局

## 一列不定宽，一列自适应

- float+overflow
- flex
- table
- grid

## 上下高度固定，中间自适应

- absolute
- flex
- table
- grid

## 两侧定宽，中栏自适应

- float
- absolute
- flex
- table
- grid
- 双飞翼
- 圣杯

## 九宫格布局

- flex
- grid
- float
- table

## 全屏布局

- flex
- position

## 单列布局，垂直居中

- table-cell
- vertical-align
- absolute
- flex
- grid

## 单列布局，水平居中

- margin
- absolute
- flex
- text-align

## 右列定宽，左列自适应

* flex
* table
* float+margin
* grid

## 多列等分布局

# 二、 css 盒模型

## 基本概念：标准模型 + IE 模型

## 标准模型和 IE 模型区别

## css 如何设置这两种模型

```
box-sizing:content-box

box-sizing:border-box
```

## js 如何获取盒模型对应高度

1.  `dom.style.width/height` (style 结点和外联样式表 取不到宽和高)
2.  `dom.currentStyle.width/height`(拿到的是浏览器最终渲染的样式，只有 ie 支持)
3.  `window.getComputedStyle(dom).width/height`(兼容 chrome.firfox)
4.  `dom.getBoundingClientRect().width/height`

## 根据盒模型解释边距重叠

## BFC(边距重叠解决方案)

### BFC 基本概念

### BFC 原理（渲染规则）

1.  属于这个元素的垂方向直边距会发生重叠
2.  不会与浮动元素的区域发生重叠（清除浮动）
3.  在页面上是一个独立的容器，外面和里面互不相干
4.  计算高度的时候，内部浮动元素也会参与计算

### 如何创建 BFC

### BFC 使用场景

# 三、 DOM 事件

## 基本概念：DOM 事件的级别

1.  DOM0 `element.onclick=function(){}`
2.  DOM2 `element.addEventListener('click',function(){},false)`
3.  DOM3 `element.addEventListener('keyup',function(){},false)` (鼠标、键盘)

## DOM 事件模型 （冒泡和捕获）

## DOM 事件流

## 描述 DOM 事件捕获的具体流程

### 事件捕获

`window->document->html->body->...->目标元素`

## Event 对象的常见应用

### 1. `event.preventDefault()`

阻止默认事件

### 2. `event.stopPropagation()`

阻止冒泡行为，父级和子元素都绑定了事件，点击子元素，只让子元素响应

### 3. `event.stopImmediatePropagation()`

事件优先级。按钮绑定两个事件，a,b，当按 a 后不执行 b，在 a 加入，可以阻止 b 执行。

### 4. `event.currentTarget`

当前所绑定的事件 的对象。父级绑定 click, currrentTarget 指定为父级元素

### 5. `event.target`

当前被点击的元素 (ie srcElement)

## 自定义事件（模拟事件）

```
var eve = new Event('custome');

ev.addEventListener('custome',function(){
    ....
});

ev.dispatchEvent(eve); // 触发
```

### Event 不足

1.  无法添加数据

### CustomEvent

1.  和 Event 功能相同
2.  可以添加参数

# 四、 HTTP 协议

## HTTP 协议的主要特点

1.  简单快速 uri
2.  灵活 (一个 http 请求 多种资源)
3.  无连接
4.  无状态

## HTTP 报文的组成部分

### 请求报文

1.  请求行
2.  请求头
3.  空行
4.  请求体

### 响应报文

1.  状态行
2.  响应头
3.  空行
4.  响应体

## HTTP 方法

## POST 和 GET 的区别

## HTTP 状态码

## 什么是持久化链接

## 什么是管线化

在使用持久连接的情况下，某个连接上消息的传递类似于

请求 1->响应 1->请求 2->相应 2-请求 3->响应 3

某个连接上的消息变成了类似这样

请求 1->请求 2->请求 3->响应 1->响应 2->响应 3

### 特点

1.  管线化机制通过持久连接完成， 仅 HTTP/1.1 支持此技术
2.  只有 GET/HEAD 请求可以进行管线化，而 POST 则有所限制
3.  初次创建连接时不应启动管线机制，因为服务器不一定支持 http1.1
4.  不会影响响应到来的顺序
5.  现代浏览器默认不开启管线化

# 五 面向对象

## 创建对象有几种方法

## 原型、构造函数、实例、原型链

`prototype`的作用就是使构造函数的实例可以访问到 它的原型对象上

## instanceof 的原理

```
__proto__ -> instanceof -> prototype ->
实例对象                    构造函数      原型
```

判断实例对象的`__proto__` 是否和构造函数的`prototype` 引用同一个地址

`construct`判断比`instanceof`更加严谨

## new 运算符

```
var new = function(func){
    var o = Object.create(func.prototype); // 第一步，创建新对象并且关联构造函数的原型对象
    var k = func.call(o); // 第二步，执行构造函数
    if(typeof k === 'object){ // 第三步，判断构造函数的执行结果是否为对象类型
        return k;
    }else{
        return o;
    }
}
```

## 类与实例

### 类的声明

### 生成实例

## 类与继承

### 如何实现继承

### 继承的几种方法

# 六、原型链

# 七、通信

## 什么是同源策略及限制

- Cookie、LocalStorage 和 IndexDB 无法读取
- DOM 无法获得
- AJAX 请求不能发送

## 前后端如何通信

- Ajax
- WebSocket
- CORS

## 如何创建 Ajax

- XMLHttpRequest 对象的工作流程
- 兼容性处理
- 事件的触发条件
- 事件的触发顺序

## 跨域通信的几种方式

- JSONP
- Hash
- postMessage
- WebSocket
- CORS

# 八、安全

## CSRF

### 基本概念和缩写

跨站请求伪造，英文名 Cross-site request forgery

### 攻击原理

1.  用户登录网站 A，网站 A 下发 cookie
2.  网站 B 引诱用户点击，访问网站 A 的接口

> - 网站中某个接口存在漏洞
> - 用户在这个网站登录过

### 防御措施

1.  Token 验证（点击引诱链接只会自动携带 cookie，不会自动携带 Token）
2.  Referer 验证（验证页面来源,服务器判断是否为）
3.  隐藏令牌 （和 Token 类似，放在请求头中，比较隐蔽）

## XSS

跨域脚本攻击

### 攻击原理

1.  不需要任何登录认证
2.  注入脚本

(输入框，加入脚本)

### 防御措施

1.  插入 js 不可执行

# 九、算法

## 排序

## 堆栈、队列、链表

## 递归

## 波兰式和逆波兰式

# 十、渲染机制

## DOCTYPE 及作用

## 浏览器渲染过程

## 重排 Reflow

### 定义

### 触发 Reflow

## 重绘 Repaint

### 定义

### 触发 Repaint

## 布局 Layout

# 十一、JS 运行机制

## 如何理解 JS 的单线程

## 什么是任务队列

## 什么是 Event Loop

## 运行机制类 异步任务

- setTimeout 和 setInterval
- DOM 事件
- ES6 中的 Promise

## 运行机制 总结

- 理解 JS 单线程的概念
- 理解任务队列
- 理解 Event Loop
- 理解哪些语句会放入异步任务队列
- 理解语句放入异步任务队列的时机

# 十二、页面性能

## 提升页面性能的方法有哪些

1.  资源压缩合并，减少 HTTP 请求
2.  非核心代码异步加载-> 异步加载的方式-> 异步加载的区别
3.  利用浏览器缓存-> 缓存的分类-> 缓存的原理
4.  使用 CDN
5.  预解析 DNS

## 异步加载

### 1.异步加载的方式

- 动态脚本加载
- defer
- async

### 2.异步加载的区别

- defer 是在 HTML 解析完之后才会执行，如果是多个，按照加载的顺序依次执行
- async 是在加载完之后立即执行，如果是多个，执行顺序和加载顺序无关

## 浏览器缓存

### 强缓存

Expires

Cache-Control

### 协商缓存

Last-Modified(服务器下发) If-Modified-Since(发给服务器) 时间

Etag(服务器下发) If-None-Match(发给服务器) 文件 hash 值

# 十三、错误监控

## 前端错误的分类

1.  即时运行错误：代码错误
2.  资源加载错误

## 错误的捕获方式

## 即时运行错误的捕获方式

1.  try...catch

2.  window.onerror

## 资源加载错误

1.  object.onerror

2.  performance.getEntries()

3.  Error 事件捕获

跨域的 js 运行错误可以捕获吗，错误提示什么，应该怎么处理

## 上报错误的基本原理

1.  采用 Ajax 通信的方式上报

2.  利用 Image 对象上报

`(new Image()).src='...'`

# 十四、

<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>

<body>
    <script>
        /*
        for (var i = 1; i <= 5; i++) {
            setTimeout(function timer() {
                console.log(i);
            }, i * 1000);
        }
        超时的回调函数都将在循环的完成之后立即运行。实际上，就计时器而言，即便在每次迭代中它是 setTimeout(.., 0)，所有这些回调函数也都仍然是严格地在循环之后运行的，因此每次都打印 6
        它们 都闭包在同一个共享的全局作用域上，而它事实上只有一个 i
        */


        /*
        for (var i=1; i<=5; i++) {
            (function(){
                setTimeout( function timer(){
                    console.log( i );
                }, i*1000 );
            })();
        }
        每个超时回调函数确实闭包在每次迭代时分别被每个 IIFE 创建的作用域中，拥有一个被闭包的 空的作用域 是不够的
        */


        /* 它需要它自己的变量，在每次迭代时持有值 i 的一个拷贝
        for (var i = 1; i <= 5; i++) {
            (function (j) {
                setTimeout(function timer() {
                    console.log(j);
                }, j * 1000);
            })(i);
        }
        */

        // 这个变量将不是只为循环声明一次，而是为每次迭代声明一次。并且，它将在每次后续的迭代中被上一次迭代末尾的值初始化。
        for (let i = 1; i <= 5; i++) {
            setTimeout(function timer() {
                console.log(i);
            }, i * 1000);
        }
    </script>
</body>

</html>
## 块儿（Chunks）中的程序

### 异步控制台

关于`console.*`方法如何工作，没有相应的语言规范或一组需求——它们不是JavaScript官方的一部分，而是由 *宿主环境* 添加到JS上的（见本丛书的 类型与文法）。


### 事件轮询（Event Loop）

在每次调用JS引擎时，可以 *随着时间的推移* 执行你的程序的多个代码块儿，这称为“事件轮询（Event Loop）”。

```
// `eventLoop`是一个像队列一样的数组（先进先出）
var eventLoop = [ ];
var event;

// “永远”执行
while (true) {
	// 执行一个"tick"
	if (eventLoop.length > 0) {
		// 在队列中取得下一个事件
		event = eventLoop.shift();

		// 现在执行下一个事件
		try {
			event();
		}
		catch (err) {
			reportError(err);
		}
	}
}
```

很重要并需要注意的是，`setTimeout(..)`不会将你的回调放在事件轮询队列上。它设置一个定时器；当这个定时器超时的时候，环境才会把你的回调放进事件轮询，这样在某个未来的tick中它将会被取出执行。


如果在那时事件轮询队列中已经有了20个事件会怎么样？你的回调要等待。它会排到队列最后——没有一般的方法可以插队和跳到队列的最前方。这就解释了为什么`setTimeout(..)`计时器可能不会完美地按照预计时间触发。你得到一个保证（粗略地说）：你的回调不会再你指定的时间间隔之前被触发，但是可能会在这个时间间隔之后被触发，具体要看事件队列的状态。



### 并行线程

异步是关于 *现在* 与 *稍后* 之间的间隙。但并行是关于可以同时发生的事情。

关于并行计算最常见的工具就是进程与线程。进程和线程独立地，可能同时地执行：在不同的处理器上，甚至在不同的计算机上，而多个线程可以共享一个进程的内存资源。

相比之下，一个事件轮询将它的工作打碎成一系列任务并串行地执行它们，不允许并行访问和更改共享的内存。并行与“串行”可能以在不同线程上的事件轮询协作的形式共存。


### 运行至完成


### 非互动

在同一个程序中两个或更多的“进程”在穿插它们的步骤/事件时，**如果它们的任务之间没有联系，那么他们就没必要互动。如果它们不互动，不确定性就是完全可以接受的**。

```
var res = {};

function foo(results) {
	res.foo = results;
}

function bar(results) {
	res.bar = results;
}

// ajax(..) 是某个包中任意的Ajax函数
ajax( "http://some.url.1", foo );
ajax( "http://some.url.2", bar );
```

### 互动

更常见的是，通过作用域和/或DOM，并发的“进程”将有必要间接地互动。当这样的互动将要发生时，你需要协调这些互动行为来防止前面讲述的“竞合状态”。
# I never understood JavaScript closures

Until someone explained it to me like this

https://medium.com/dailyjs/i-never-understood-javascript-closures-9663703368e8

正如标题所述，JavaScript 封闭对我来说一直是个谜。我已经阅读了多篇文章，我在工作中使用了闭包，我有时甚至没有意识到自己正在使用闭包。

最近我去了一个演讲，有人以最明确的方式给我解释了它。 我将尝试用这种方法来解释本文中的闭包。 让我赞扬 CodeSmith 的优秀人才和他们的 JavaScript The Hard Parts 系列。

## 在我们开始之前

在你可以理解闭包之前，一些概念很重要。其中之一就是 执行上下文

[这篇文章](http://davidshariff.com/blog/what-is-the-execution-context-in-javascript/)很好的解释了执行上下文。下面是引用这篇文章所说的

> 当代码在 JavaScript 中运行时，执行它的环境非常重要，并被评估为以下 1 之一

> 全局代码 - 首次执行代码的默认环境。
> 函数代码 - 每当执行流程进入函数体时

> 让我们将术语执行上下文视为正在评估当前代码的环境/范围

换句话说，当我们启动程序时，我们将从全局执行上下文开始执行。一些变量在全局执行上下文中声明，我们称这些为全局变量。当程序调用函数时，会发生以下几个步骤：

1. JavaScript 在当前执行上下文中创建新的执行上下文

2. 该当前执行上下文将拥有自己的变量，这些变量将是这个执行上下文的当前变量

3. 新的执行上下文将会进栈（执行栈）。我们把执行堆栈视为一种机制，这样有利于跟踪程序执行的位置

当遇到`return`语句或遇到结束括号时`}`时，函数将会结束，并会发生以下情况：

1. 当前执行上下文从执行堆栈中出栈

2. 函数将会反回一个值给调用它的上下文。调用这个函数的上下文可以是全局执行上下文或者是另一个本地执行上下文。由调用这个函数的执行上下文来处理该点的返回值。返回的值可以是对象，数组，函数，布尔值，任何东西。如果函数没有`return`语句，则返回`undefined`。

3. 当前的执行上下文将会被销毁。在当前执行上下文中声明的所有变量都将被删除，他们不能再次使用，这也是他们被称为局部变量的原因

## 一个基础的例子

在我们学习闭包之前，让我们看一下下面这段代码。这看起来非常简单，任何读这篇文章的人都可能确切知道它的作用

```
1: let a = 3
2: function addTwo(x) {
3:   let ret = x + 2
4:   return ret
5: }
6: let b = addTwo(a)
7: console.log(b)
```

为了理解 JavaScript 引擎的真正工作原理，以下将会详细介绍

1. 在第 1 行我们在全局作用域中声明了一个新的变量 `a`并赋值 `3`。

2. 2 到 5 行是一起的。我们在全局作用域中声明了一个新的变量`addTwo`。我们将已函数来定义并赋值给它。两个括号`{}`之间的任何内容都分配给`addTwo`。 函数内部的代码不会被 evaluated，也不会执行，只是存储到变量中以备将来使用

3. 现在我们看看第 6 行。它看起来很简单，但在这里省略了很多步骤。首先，我们在全局作用域中声明了一个新的变量。一旦这个变量被声明，它最先将被赋值为`undefined`

4. 下一步，仍然在第 6 行。我们可以看到一个赋值操作。我们准备为变量 `b` 分配赋一个新值。接下来我们看到一个函数被调用。当你看到一个变量后跟圆括号`（...）`时，这就是调用函数的信号。每个函数都会返回一些东西（值，对象或`undefined`）。 从函数返回的任何内容都将分配给变量 `b`

5. 当我们要调用函数`addTwo`时,js 先会现在全局上下文中查找是否存在变量名为`addTwo`的变量。这里变量在第 2 步(2-5)已经定义了，变量`addTwo`包含一个函数定义。请注意，之后变量`a`作为参数传递给函数。js 在其全局执行上下文内存中搜索到变量`a`,并把它的值`3`赋值给函数的参数，然后准备执行这个函数。

6. 现在执行上下文将会切换。一个新的当前执行上下文将会被创建，我们将它命名为 "addTwo 的执行上下文"。这个执行上下文将会被推入调用栈中。我们在当前执行上下文中做的第一件事是什么？

7. 你可能会想说，“在本地执行上下文中声明了一个新的变量`ret`”。这不是答案。正确的答案是，我们首先需要查看函数的参数。在当前执行上下文中声明了一个新变量`x`，并且由于值`3`作为参数传递，因此变量`x`被赋值为`3`

8. 一个新的变量 `ret`在当前执行上下文中声明。这个变量的值被设为`undefined`(第 3 行)

9. 第 3 行需要进行添加。我们首先需要一个值`x`,js 会查找一个变量 `x`。它会先从当前执行上下文中查找，发现了一个值为`3`。然后与 2 相加，最后赋值把结果 5 赋值到`ret`中。

10. 弟 4 行，返回一个包含变量`ret`的内容。当前执行上下文中开始新的查找。 `ret`包含值 5.函数返回数字 5.函数结束。

11. 弟 4-5 。函数结束。当前执行上下文被销毁。变量`x`和`ret`被清除。这个上下文被推出调用栈并且返回一个值到调用这个函数的上下文中。在这种情况下，调用上下文其实就是全局执行上下文，因为函数`addTwo`是从全局执行上下文中调用的

12. 现在我们选择在步骤 4 中停止的位置。返回值（数字 `5`）被分配给变量`b`。我们仍然在小程序的第 6 行

13. 我不会再详细说下去了，但在第 7 行，包含变量`b`的区域打印一条信息

对于一个非常简单的程序来说，这是一个非常冗长的解释，我们甚至还没有涉及到闭包。我保证之后会解释，但在此之前我们需要再绕一两次

## 词法作用域

我们需要了解词法作用域的某些方面。看一下下面的例子

```
1: let val1 = 2
2: function multiplyThis(n) {
3:   let ret = n * val1
4:   return ret
5: }
6: let multiplied = multiplyThis(6)
7: console.log('example of scope:', multiplied)
```

这里的情况是，我们在当前执行上下文中有变量，在全局执行上下文中也有有变量。 JavaScript 的一个复杂之处在于它如何查找变量。 如果它在当前执行上下文中找不到变量，它将在其调用它的上下文中查找。 如果没有在其调用上下文中找到,它将会再往上一层进行查找。 类似这样一直下去，直到它查找到全局执行上下文。 （如果它没有找到，变量的值为`undefined`）。 从下面的例子比较清晰地解释其原理， 如果您了解范围的工作原理，则可以跳过此步骤

1. 在全局执行上下文中声明一个新变量`val1`，并为其分配数字`2`

2. 第 2-5 行。声明一个新变量`multiplyThis`并为其赋值函数定义

3. 第 6 行。在全局执行上下文中 声明一个新变量`multiplied`。

4. 从全局执行上下文内存中检索变量 `multiplyThis` 并将其作为函数执行。将数字 `6` 作为参数传递

5. 新函数调用=新执行上下文。创建新的本地执行上下文。

6. 在本地执行上下文中，声明一个变量 `n` 并为其分配数字 `6`。

7. 第 3 行。在本地执行上下文中，声明一个变量 `ret`。

8. 第 3 行（续）。变量 `n`和 `val1` 执行乘法运算。在本地执行上下文中查找变量 `n`。我们在步骤 6 中声明了它。它的内容是数字 `6`.然后在本地执行上下文中查找变量 `val1`，本地执行上下文没有标记为 `val1` 的变量,我们来检查调用上下文。调用上下文是全局执行上下文。我们在全局执行上下文中查找`val1`,它就在那里。它在步骤 1 中定义。值为数字 `2`。

9. 第 3 行（续）。将两个操作数相乘并将其分配给 `ret` 变量。 `6 * 2 = 12`. `ret` 现在是 `12`

10. 返回 `ret` 变量。本地执行上下文及其变量 `ret` 和 `n` 被销毁。变量 `val1` 不会被销毁，因为它是全局执行上下文的一部分。

11. 返回第 6 行。在调用上下文中，将数字 `12` 分配给变量`multiplied`

12. 最后在第 7 行，我们在控制台中显示相乘变量的值。

以在这个例子中，我们需要记住一个函数可以访问在其调用上下文中定义的变量。这种现象的正式名称是词法作用域

## 一个返回函数的函数

在第一个示例中，函数 `addTwo` 返回一个数字。 请记住，之前说过函数可以返回任何内容。 让我们看一个返回函数的函数示例，因为这对理解闭包很重要。 以下是我们要分析的示例

```
 1: let val = 7
 2: function createAdder() {
 3:   function addNumbers(a, b) {
 4:     let ret = a + b
 5:     return ret
 6:   }
 7:   return addNumbers
 8: }
 9: let adder = createAdder()
10: let sum = adder(val, 8)
11: console.log('example of function returning a function: ', sum)
```

1. 第 1 行。我们在全局执行上下文中声明一个变量`val`，并将数字`7`赋给该变量。

2. 第 2-8 行。 我们在全局执行上下文中声明了一个名为 `createAdder` 的变量，并为其分配了一个函数定义。 第 3 至 7 行描述了函数定义。 和以前一样，在这一点上，我们并没有跳进那个函数。 我们只是将函数定义存储到该变量（`createAdder`）中。

3. 第 9 行。我们在全局执行上下文中声明一个名为 `adder` 的新变量。暂时，`undefined`会被赋值给`adder`。

4. 仍然是第 9 行。我们看到括号`（）`;我们需要执行或调用函数。让我们查询全局执行上下文的内存并查找名为 `createAdder` 的变量。它是在第 2 步中创建的。好的，接下来调用它.

5. 调用一个函数。 现在我们在第 2 行。创建了一个新的本地执行上下文。 我们可以在新的执行上下文中创建局部变量。 js 引擎将新上下文添加到调用堆栈中。 该函数没有参数，让我们直接进入它的主体

6. 仍然是 3-6 行。 我们有一个新的函数声明。 我们在本地执行上下文中创建变量 `addNumbers`。 这很重要。 `addNumbers` 仅存在于本地执行上下文中。 我们将函数定义存储在名为 `addNumbers` 的局部变量中

7. 现在我们在第 7 行。我们返回变量 `addNumbers` 的内容。 js 引擎查找名为 `addNumbers` 的变量并找到它。 这是一个函数定义。 一个函数可以返回任何东西，包括函数定义。 所以我们返回 `addNumbers` 的定义。 第 4 行和第 5 行的括号之间的任何内容构成了函数定义。 我们还从调用堆栈中删除了本地执行上下文

8. 返回后，本地执行上下文将被销毁。 `addNumbers` 变量不再存在。 函数定义仍然存在，它从函数返回并分配给我们在第 3 步中创建的变量`adder`

9. 现在我们在第 10 行。我们在全局执行上下文中定义一个新的变量 `sum`。临时分配`undefined`给这个变量。

10. 我们需要接下来执行一个函数。哪个函数？在名为 `adder` 的变量中定义的函数。我们在全局执行环境中查找它，我们确实找到了它。这是一个带两个参数的函数。

11. 让我们检索两个参数，这样我们就可以调用函数并传递正确的参数。第一个是变量 `val`，我们在步骤 1 中定义，它代表数字 `7`，第二个是数字 `8`

12. 现在我们必须执行该函数。 函数定义概述在第 3-5 行。 创建新的本地执行上下文。 在本地上下文中，创建了两个新变量：`a` 和`b`。 它们分别被赋值为 `7` 和 `8`，因为它们是我们在上一步中传递给函数的参数

13. 第 4 行。声明一个新变量，名为 `ret`。它在本地执行上下文中声明。

14. 第 4 行。执行添加，其中我们添加变量 `a` 的内容和变量 `b` 的内容。加法的结果（`15`）被赋值给 `ret` 变量。

15. `ret` 变量从该函数中返回。本地执行上下文被销毁，它从调用堆栈中删除，变量 `a`，`b` 和 `ret` 不再存在。

16. 返回的值将分配给我们在步骤 9 中定义的 `sum` 变量。

17. 我们将 `sum` 的值打印到控制台。

正如预期的那样，控制台将打印 15.我们真的经历了一堆箍。 我想在这里说明几点。 首先，函数定义可以存储在变量中，函数定义对程序是不可见的，直到被调用。 其次，每次调用函数时，本地执行上下文将被（临时）创建。 当函数完成时，执行上下文消失。 函数在遇到 `return` 或者 关闭括号`}`时表示执行完成。

## 闭包

看看下一个代码，并试着弄清楚会发生什么。

```
1: function createCounter() {
2:   let counter = 0
3:   const myFunction = function() {
4:     counter = counter + 1
5:     return counter
6:   }
7:   return myFunction
8: }
9: const increment = createCounter()
10: const c1 = increment()
11: const c2 = increment()
12: const c3 = increment()
13: console.log('example increment', c1, c2, c3)
```

现在我们从之前的两个例子中得到了它，让我们按照我们期望它运行的方式执行此操作。

1. 第 1-8 行。我们在全局执行上下文中创建一个新变量 `createCounter`，并获得已分配的函数定义。

2. 第 9 行。我们在全局执行上下文中声明一个名为 `increment` 的新变量。

3. 第 9 行。我们需要调用 `createCounter` 函数并将其返回值赋给 `increment` 变量

4. 第 1-8 行。调用函数。创建新的本地执行上下文。

5. 第 2 行。在本地执行上下文中，声明一个名为 `counter` 的新变量。数字 `0` 分配给`counter`。

6. 第 3-6 行。声明名为 `myFunction` 的新变量。该变量在本地执行上下文中声明。变量的内容是另一个函数定义。如第 4 和第 5 行所定义。

7. 第 7 行。返回 `myFunction` 变量的内容。删除本地执行上下文。 `myFunction` 和`counter`不再存在。控制返回到调用上下文。

8. 第 9 行。在调用上下文中，全局执行上下文，`createCounter` 返回的值被赋值为 `increment`。 变量 `increment` 现在包含一个函数定义。 `createCounter` 返回的函数定义。 它不再标记为 `myFunction`，但它的定义相同。 在全球上下文中，它被标记为`increment`。

9. 第 10 行。声明一个新变量（`c1`）

10. 第 10 行（续）。查找变量`increment`，它是一个函数，调用它。它包含从前面返回的函数定义，如第 4-5 行中所定义。

11. 创建一个新的执行上下文。没有参数。开始执行该函数。

12. 第 4 行.`counter = counter + 1`.在本地执行上下文中查找`counter`。 我们刚刚创建了上下文，并且从不声明任何局部变量。 让我们看看全局执行上下文。 这里没有变量标记`counter`。 Javascript 将此计算为 `counter = undefined + 1`，声明一个标记为 `counter` 的新局部变量并为其指定数字 `1`，因为 `undefined` 是 `0`

13. 第 5 行。我们返回`counter`的内容或数字 `1`.我们销毁本地执行上下文和`counter`变量

14. 返回第 10 行。返回值（1）被分配给 c1

15. 第 11 行。我们重复步骤 10-14，c2 也被分配 1。

16. 第 12 行。我们重复步骤 10-14，c3 也被分配 1。

17. 第 13 行。我们打印变量 c1，c2 和 c3 的内容。

亲自尝试一下，看看会发生什么。您会注意到它没有打印 1,1 和 1，正如您对我上面的解释所期望的那样。相反，它打印了 1,2 和 3.为什么会出现这样的结果？

不知何故，`increment`函数会记住`counter`值。那是怎么样实现的？

`counter`是全局执行环境的一部分吗？尝试 `console.log(counter)`，你将得到`undefined`。所以它不是全局执行环境的一部分

也许，当你调用`increment`时，它会以某种方式返回到它创建的函数（`createCounter`）？它是如何工作的呢？变量`increment`包含一个函数定义，而不是它来自何处，所以它不是`counter`。所以肯定有另一种机制，那就是闭包，我们终于见到了它，失踪的那一部分。

下面是它的工作原理。每当声明一个新函数并将其赋值给变量时，都会存储函数定义以及闭包。 **闭包**包含创建函数时范围内的所有变量,它类似于背包。函数定义附带一个小背包。 在它的包中，它存储了创建函数定义时范围内的所有变量

所以我们上面的解释都是错误的，让我们再试一次，但这次是正确的

```
1: function createCounter() {
 2:   let counter = 0
 3:   const myFunction = function() {
 4:     counter = counter + 1
 5:     return counter
 6:   }
 7:   return myFunction
 8: }
 9: const increment = createCounter()
10: const c1 = increment()
11: const c2 = increment()
12: const c3 = increment()
13: console.log('example increment', c1, c2, c3)
```

1. 第 1-8 行。我们在全局执行上下文中创建一个新变量 `createCounter`，并获得已分配的函数定义。与上面相同。

2. 第 9 行。我们在全局执行上下文中声明一个名为 `increment` 的新变量。与上面相同。

3. 第 9 行。我们需要调用 `createCounter` 函数并将其返回值赋给 `increment` 变量。与上面相同。

4. 第 1-8 行。调用函数。创建新的本地执行上下文。与上面相同。

5. 第 2 行。在本地执行上下文中，声明一个名为 `counter` 的新变量。数字 `0` 分配给`counter`。与上面相同。

6. 3-6 行。 声明名为 `myFunction` 的新变量。 该变量在本地执行上下文中声明。 变量的内容是另一个函数定义。 如第 4 行和第 5 行中所定义的。现在我们还将创建一个闭包并将其作为函数定义的一部分包含在内。 闭包含包含作用域范围内的变量，在本例中为变量 `counter`（值为 `0`）。

7. 第 7 行。返回 `myFunction` 变量的内容。 删除本地执行上下文。 `myFunction` 和`counter`不再存在。 控制返回到调用上下文。 所以我们返回函数定义及其闭包，背包中包含创建时范围内的变量

8. 第 9 行。在调用上下文中，也就是全局执行上下文，`createCounter` 返回的值被赋值为 `increment`。 变量`increment`现在包含一个函数定义（和闭包）。 `createCounter` 返回的函数定义。 它不再标记为 `myFunction`，但它的定义相同。 在全局上下文中，它被称为`increment`

9. 第 10 行。声明一个新变量（`c1`）。

10. 第 10 行（续）。查找变量`increment`，它是一个函数，并调用它。它包含从前面返回的函数定义，如第 4-5 行中所定义。 （还有一个带变量的背包）

11. 创建一个新的执行上下文。没有参数。开始执行该函数

12. 第 4 行.`counter = counter + 1`.我们需要查找变量`counter`。 在我们查看本地或全局执行环境之前，让我们看看我们的背包。 我们来检查闭包。 请注意，闭包包含一个名为 `counter` 的变量，其值为 `0`.在第 4 行的表达式之后，其值设置为 `1`.然后它再次存储在背包中。 闭包现在包含值为 `1` 的变量`counter`。

13. 第 5 行。我们返回`counter`的内容或数字`1`.我们销毁本地执行上下文

14. 返回第 10 行。返回值（`1`）被分配给 `c1`。

15. 第 11 行。我们重复步骤 10-14。 这次，当我们查看闭包时，我们看到`counter`变量的值为 `1`.它在程序的步骤 12 或第 4 行中设置。 它的值递增并在`increment`函数的闭包中存储为 2。 并且 `c2` 被分配 `2`。

16. 第 12 行。我们重复步骤 10-14，`c3` 被分配 `3`

17. 第 13 行。我们记录变量 `c1`，`c2` 和 `c3` 的内容。

所以现在我们了解这是如何工作的。要记住的关键是当声明一个函数时，它包含一个函数定义和一个闭包。闭包是函数创建时范围内所有变量的集合。

您可能会问，任何函数是否都有闭包，甚至是在全局范围内创建的函数？ 答案是肯定的。 在全局范围中创建的函数会创建一个闭包。 但由于这些函数是在全局范围内创建的，因此它们可以访问全局范围内的所有变量，所以闭包的概念没有那么明显

当函数返回一个函数时，就是闭包的概念表现得比较明显。返回的函数可以访问不在全局范围内的变量，但它们仅存在于其闭包中。

## 闭包无处不在

当你甚至没有注意到它时，有时会出现闭包。您可能已经看到了我们称之为部分应用程序的示例。如下面的代码。

```
let c = 4
const addX = x => n => n + x
const addThree = addX(3)
let d = addThree(c)
console.log('example partial application', d)
```

上面的代码等效于下面的代码

```
let c = 4
function addX(x) {
  return function(n) {
     return n + x
  }
}
const addThree = addX(3)
let d = addThree(c)
console.log('example partial application', d)
```

我们声明了一个通用加法器函数 `addX`，它接受一个参数（`x`）并返回另一个函数。返回的函数也接受一个参数并将其添加到变量 `x`。变量 `x` 是闭包的一部分。当变量 `addThree` 在本地上下文中声明时，会为其分配一个函数定义和一个包括变量 `x`的闭包。

所以现在当调用并执行 `addThree` 时，它可以从其闭包中获取变量 `x`，并且可以作为参数传递变量 `n`并且能够返回他们的和,最后打印的值为`7`

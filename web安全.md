## 1. sql 注入

### (1)原理：

就是通过把 SQL 命令插入到 Web 表单递交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意的 SQL 命令。

### (2) 防范:

* 永远不要信任用户的输入，要对用户的输入进行校验，可以通过正则表达式，或限制长度，对单引号和双"-"进行转换等。
* 永远不要使用动态拼装 SQL，可以使用参数化的 SQL 或者直接使用存储过程进行数据查询存取。
* 永远不要使用管理员权限的数据库连接，为每个应用使用单独的权限有限的数据库连接。
* 不要把机密信息明文存放，请加密或者 hash 掉密码和敏感的信息。

## 2.XSS（Cross Site Scripting）

### (1) 原理:

跨站脚本攻击。攻击者往 Web 页面里插入恶意 `html` 标签或者 `javascript` 代码。比如：攻击者可以发送 Email，或者在各种论坛网站中放一个看似安全的链接，骗取用户点击后，窃取 cookie 中的用户私密信息；或者攻击者在论坛中加一个恶意表单，当用户提交表单的时候，却把信息传送到攻击者的服务器中，而不是用户原本以为的信任站点。

### (2) 方式：

#### Reflected XSS（基于反射的 XSS 攻击）

基于反射的 XSS 攻击，主要依靠站点服务端返回脚本，在客户端触发执行从而发起 Web 攻击。例子：

1.  做个假设，当亚马逊在搜索书籍，搜不到书的时候显示提交的名称。
2.  在搜索框搜索内容，填入`“<script>alert('handsome boy')</script>”`, 点击搜索。
3.  当前端页面没有对返回的数据进行过滤，直接显示在页面上， 这时就会 alert 那个字符串出来。
4.  进而可以构造获取用户 cookies 的地址，通过 QQ 群或者垃圾邮件，来让其他人点击这个地址：

防范：

* 前端在显示服务端数据时候，不仅是标签内容需要过滤、转义，就连属性值也都可能需要。
* 后端接收请求时，验证请求是否为攻击请求，攻击则屏蔽。

#### Stored XSS（基于存储的 XSS 攻击）

基于存储的 XSS 攻击，是通过发表带有恶意跨域脚本的帖子/文章，从而把恶意脚本存储在服务器，每个访问该帖子/文章的人就会触发执行。例子：

1.  发一篇文章，里面包含了恶意脚本
    `今天天气不错啊！<script>alert('handsome boy')</script>`
2.  后端没有对文章进行过滤，直接保存文章内容到数据库。
3.  当其他看这篇文章的时候，包含的恶意脚本就会执行。
    PS：因为大部分文章是保存整个 HTML 内容的，前端显示时候也不做过滤，就极可能出现这种情况。

防范：

* 首要是服务端要进行过滤，因为前端的校验可以被绕过。
* 当服务端不校验时候，前端要以各种方式过滤里面可能的恶意脚本，例如 script 标签，将特殊字符转换成 HTML 编码。

#### DOM-based or local XSS（基于 DOM 或本地的 XSS 攻击）

基于 DOM 或本地的 XSS 攻击。一般是提供一个免费的 wifi，但是提供免费 wifi 的网关会往你访问的任何页面插入一段脚本或者是直接返回一个钓鱼页面，从而植入恶意脚本。这种直接存在于页面，无须经过服务器返回就是基于本地的 XSS 攻击。例子：

1.  提供一个免费的 wifi。
2.  开启一个特殊的 DNS 服务，将所有域名都解析到我们的电脑上，并把 Wifi 的 DHCP-DNS 设置为我们的电脑 IP。
3.  之后连上 wifi 的用户打开任何网站，请求都将被我们截取到。我们根据 http 头中的 host 字段来转发到真正服务器上。
4.  收到服务器返回的数据之后，我们就可以实现网页脚本的注入，并返回给用户。
5.  当注入的脚本被执行，用户的浏览器将依次预加载各大网站的常用脚本库。

这攻击其实跟网站本身没有什么关系，只是数据被中间人获取了而已，而由于 HTTP 是明文传输的，所以是极可能被窃取的。

防范：

* 使用 HTTPS！就跟我前面《HTTP 与 HTTPS 握手的那些事》这篇文章说的，HTTPS 会在请求数据之前进行一次握手，使得客户端与服务端都有一个私钥，服务端用这个私钥加密，客户端用这个私钥解密，这样即使数据被人截取了，也是加密后的数据。

#### 具体例子

美女 A 在某相亲网站上自己的签名里嵌入一段 script，当宅男 B 点击 A 的签名时，运行这段 script，附带 cookie 访问链接里的美女 A 私有服务器，其实 A 只是一盗用美女照片的抠脚大汉，抠脚大汉就可以使用带有 cookie 的链接登录 B 的账户。通过发送带有附件的邮件，附件是木马程序，用户只要双击打开，一个邪恶的种子就埋下了，这个木马程序可以收集用户敏感信息，源源不断发送出去，这个木马还可以接受远程控制，随时可以发动 DDoS 攻击。

#### http-only

js 不能操作 cookie。缺点是所有站点都不可以操作

## 3.CSRF（Cross-site request forgery）

### (1)简介：

跨站请求伪造。攻击者盗用你的身份，以你的名义发送恶意请求。可以做的的事情：发邮件、发消息、盗取账号、购买商品，导致个人隐私泄露已经财产安全

### (2)原理：

登录受信任的网站 A，并且在本地生成 cookie,在不登出 A 网站的情况下，访问危险网站 B。**CSRF 攻击是源于 WEB 的隐式身份验证机制！WEB 的身份验证机制虽然可以保证一个请求是来自于某个用户的浏览器，但却无法保证该请求是用户批准发送的！**

### (3)例子：

#### 简单版：

假如博客园有个加关注的 GET 接口，blogUserGuid 参数很明显是关注人 Id，如下：
`http://www.cnblogs.com/mvc/Follow/FollowBlogger.aspx?blogUserGuid=4e8c33d0-77fe-df11-ac81-842b2b196315`
那我只需要在我的一篇博文内容里面写一个 img 标签：
`<img style="width:0;" src="http://www.cnblogs.com/mvc/Follow/FollowBlogger.aspx?blogUserGuid=4e8c33d0-77fe-df11-ac81-842b2b196315" />`
那么只要有人打开我这篇博文，那就会自动关注我。

#### 升级版：

假如博客园还是有个加关注的接口，不过已经限制了只获取 POST 请求的数据。这个时候就做一个第三方的页面，但里面包含 form 提交代码，然后通过 QQ、邮箱等社交工具传播，诱惑用户去打开，那打开过博客园的用户就中招了。

```html
<!DOCTYPE HTML>
<html lang="en-US">
<head>
<title>CSRF SHOW</title>
</head>
     <body>
          <iframe style="display:none;" src="test2.html"></iframe>
     </body>
</html>

<!DOCTYPE HTML>
<html lang="en-US">
<head>
<title>CSRF GET</title>
<body>
     <form  name="form1" action="http://www.cnblogs.com/mvc/Follow/FollowBlogger.aspx" method="post">
          <input type="hidden" name="blogUserGuid" value="4e8c33d0-77fe-df11-ac81-842b2b196315"/>
          <input type="submit" value>
     </form>
     <script>
          document.forms.form1.submit();
     </script>
</body>
</html>
```

### (4)防御:

#### 尽量使用 POST，限制 GET

GET 接口太容易被拿来做 CSRF 攻击，只要构造一个 img 标签，而 img 标签又是不能过滤的数据。接口最好限制为 POST 使用，GET 则无效，降低攻击风险。

当然 POST 并不是万无一失，攻击者只要构造一个 form 就可以，但需要在第三方页面做，这样就增加暴露的可能性。

#### 客户端页面增加伪随机数。（有问题）

1.  Cookie Hashing(所有表单都包含同一个伪随机值)
2.  在表单里增加 Hash 值，以认证这确实是用户发送的请求。
3.  然后在服务器端进行 Hash 值验证

#### 通过验证码的方法

1.  每次的用户提交都需要用户在表单中填写一个图片上的随机字符串，厄....这个方案可以完全解决 CSRF，但个人觉得在易用性方面似乎不是太好，还有听闻是验证码图片的使用涉及了一个被称为 MHTML 的 Bug，可能在某些版本的微软 IE 中受影响。

#### One-Time Tokens(不同的表单包含一个不同的伪随机值)

1.  用户访问某个表单页面。
2.  服务端生成一个 Token，放在用户的 Session 中，或者浏览器的 Cookie 中。
3.  在页面表单附带上 Token 参数。
4.  用户提交请求后， 服务端验证表单中的 Token 是否与用户 Session（或 Cookies）中的 Token 一致，一致为合法请求，不是则非法请求。

## 4.XSS 与 CSRF 有什么区别吗？

`XSS`是获取信息，不需要提前知道其他用户页面的代码和数据包。`CSRF`是代替用户完成指定的动作，需要知道其他用户页面的代码和数据包。

要完成一次 CSRF 攻击，受害者必须依次完成两个步骤:

1.  登录受信任网站 A，并在本地生成 Cookie。
2.  在不登出 A 的情况下，访问危险网站 B。

## 常见 web 安全及防护原理

1.  sql 注入,就是通过把 SQL 命令插入到 Web 表单递交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意的 SQL 命令。
2.  XSS,指的是攻击者往 Web 页面里插入恶意 html 标签或者 javascript 代码。比如：攻击者在论坛中放一个看似安全的链接，骗取用户点击后，窃取 cookie 中的用户私密信息；或者攻击者在论坛中加一个恶意表单，当用户提交表单的时候，却把信息传送到攻击者的服务器中，而不是用户原本以为的信任站点。
3.  CSRF,是代替用户完成指定的动作，需要知道其他用户页面的代码和数据包。要完成一次 CSRF 攻击，受害者必须依次完成两个步骤：1、登录受信任网站 A，并在本地生成 Cookie。2、在不登出 A 的情况下，访问危险网站 B。

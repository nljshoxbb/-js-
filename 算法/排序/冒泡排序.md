### 冒泡排序

> 相邻两个对比，最后把最大的排到了最后，重复此过程。

#### 分析

> 以数组 arr = [5, 1, 4, 2, 8] 为例说明，加粗的数字表示每次循环要比较的两个数字第一次外循环
> ( **5** **1** 4 2 8 ) → ( **1** **5** 4 2 8 )， 5 > 1 交换位置
> ( 1 **5** **4** 2 8 ) → ( 1 **4** **5** 2 8 )， 5 > 4 交换位置
> ( 1 4 **5** **2** 8 ) → ( 1 4 **2** **5** 8 )， 5 > 2 交换位置
> ( 1 4 2 **5** **8** ) → ( 1 4 2 **5** **8** )， 5 < 8 位置不变

> 第二次外循环（除开最后一个元素 8，对剩余的序列）
> ( **1** **4** 2 5 8 ) → ( **1** **4** 2 5 8 )， 1 < 4 位置不变
> ( 1 **4** **2** 5 8 ) → ( 1 **2** **4** 5 8 )， 4 > 2 交换位置
> ( 1 2 **4** **5** 8 ) → ( 1 2 **4** **5** 8 )， 4 < 5 位置不变

> 第三次外循环（除开已经排序好的最后两个元素，可以注意到上面的数组其实已经排序完成，但是程序本身并不知道，所以还要进行后续的循环，直到剩余的序列为 1）
> ( **1** **2** 4 5 8 ) → ( **1** **2** 4 5 8 )
> ( 1 **2** **4** 5 8 ) → ( 1 **2** **4** 5 8 )

> 第四次外循环（最后一次）
> ( 1 2 4 5 8 ) → ( 1 2 4 5 8 )

```
function bubbleSort(array) {
   var length = array.length,
       i,
       j,
       temp;
   for (i = length - 1; 0 < i; i--) {
       for (j = 0; j < i; j++) {
           if (array[j] > array[j + 1]) {
               temp = array[j];
               array[j] = array[j + 1];
               array[j + 1] = temp;
           }
       }
   }
   return array;
}
```